# 操作系统

## 进程和线程

1. **进程：** 进程是**操作系统进行资源调度和分配的基本单位**，实现了操作系统的并发。
2. **线程：** 线程是进程的子任务，是**CPU调度和分派的基本单位**。它是比进程更小的能独立运行的基本单位，线程自己基本不拥有系统资源，只拥有一些运行过程中必不可少的资源，同一进程中的线程共享进程所用有的全部资源。
3. **关系：** 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式（是说通过内存页表等机制，保护进程间的地址空间不会相互冲突，一个进程的操作不会修改另一个进程的地址空间中的数据）下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

4. **什么情况下使用进程和线程**：

        1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的

        2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应

        3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程

        4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求

        5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好
           因为我的项目中需要对数据段的数据共享，可以被多个程序所修改，所以使用线程来完成此操作，无需加入复杂的通信机制，使用进程需要添加复杂的通信机制实现数据段的共享，增加了我的代码的繁琐，而且使用线程开销小，项目运行的速快，效率高。
           如果只用进程的话，虽然安全性高，但是对代码的简洁性不好，程序结构繁琐，开销比较大，还需要加入复杂的通信机制，会使得我的项目代码量大大增加，切换速度会变的很慢，执行效率降低不少。

## 进程之间的通信方式（数据的流通和进程的同步互斥方式）

1. **管道：** 管道是一种半双工的通信方式，数据只能单向流动，而且只能在有血缘关系的进程之间使用，进程的血缘关系通常指的是父子进程关系

2. **命名管道FIFO：** 也是半双工的通信方式，但是它允许无亲缘关系的进程通信

3. **信号：** 是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生

4. **信号量：** 信号量是一个计数器，可用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也在访问该资源。因此，**主要作为进程间以及同一个进程内不同线程之间的同步和互斥手段**。

5. **消息队列:** 消息队列是由消息组成的链表，存放在内核中，并由消息队列标识符识别。消息队列克服了信号传递消息少，管道缓冲区大小受限等缺点。

6. **共享内存：** 就是映射一段能够被其他进程所访问的内存，这段共享内存由一个进程所创建，但多个进程都可以访问，**共享内存是最快的进程通信方式**，它往往与其他通信机制，如信号量等配合使用，来实现进程间的同步和通信。

7. **套接字：** 套接字也是进程间的通信机制，它可用于网络中不同机器之间的进程通信。

## 线程间的通信机制（同步互斥方式）

1. **临界区：** 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。它并不是核心对象，不是属于操作系统维护的，而是属于进程维护的

2. **互斥对象：** 互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源

3. **事件：**  通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作  
1 事件是内核对象，事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。  
2 事件可以由SetEvent()来触发，由ResetEvent()来设成未触发。还可以由PulseEvent()来发出一个事件脉冲。  
3 事件可以解决线程间同步问题，因此也能解决互斥问题。

3. **信号量：** 在创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离开的同时通过函数将当前可用资源计数加1 。在任何时候当前可用资源计数决不可能大于最大资源计数。

## 内核态和用户态

1. **用户态和内核态：**  
当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在0级特权级上时，就可以称之为运行在内核态。  
虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。  
当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发sys_fork()的执行时，就切换到了内核态。

2. **用户态和内核态的切换**  
1）用户态切换到内核态的三种方式  
**a.系统调用（主动的）** 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新的进程的系统调用，而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。  
**b.异常（被动的）** 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发当前运行进程切换到处理此异常的内核相关程序中，也就是转到了内核态，比如缺页异常。  
**c.外围设备的中断（被动的）** 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂时执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就由用户态到内核态的转换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。


3. **为什么要用用户态和内核态？**  
由于需要受限不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络，CPU划分出两个权限等级——用户态和内核态

## 死锁和解决办法

## 分页和虚拟内存

## 进程调度算法

  

# 计算机网络

## HTTP和HTTPS

1. **http协议：** 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议。

2. **https协议：** https是一种通过计算机网络进行安全通信的传输协议，经由http进行通信，利用SSL/TLS建立安全信道，加密数据包。https协议使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私和安全性。 

## HTTP1.0、HTTP1.1和HTTP2.0的区别

**HTTP1.0和HTTP1.1的区别:**  

        1.1 长连接(Persistent Connection)
        HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求 和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.1需要使用keep-alive参数来告知服务器端要建立一个长连接。

        1.2 节约带宽
        HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。

        1.3 HOST域
        在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。

        1.4缓存处理
        在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

        1.5错误通知的管理
        在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 

**HTTP1.1和HTTP2.0的区别：**   

        2.1 多路复用
        HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。

        2.2 头部数据压缩
        在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。
        HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

        2.3 服务器推送
        服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。
        为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。

## TCP和UDP的区别

1. **相同点：** 都是传输层协议

2. **TCP（传输控制协议）** 提供的是面向连接，可靠的字节流服务。即客户端和服务器交换数据前，必须在双方之间建立一个TCP连接，之后才能传输数据，并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端  
使用TCP协议的有：1、HTTP协议；2、HTTPS协议；3、SSH协议：4、Telnet协议；5、FTP协议；6、SMTP协议

3. **UDP（用户数据报协议）** 是一个简单的面向数据报的传输层协议，它不提供可靠性，只是把应用程序的数据传给IP层的数据发送出去，但是不能保证它们能够到达目的地。由于UDP在传输数据前不用再客户端课服务器之间建立一个连接，且没有超时重传等机制，所以传送速度很快  
使用UDP协议的有：1、NFS:网络文件系统；2、TFTP:简单文件传输协议；3、DHCP:动态主机配置协议；4、BOOTP:启动协议（用户无盘设备启动）；5、DNS:域名解析协议

4. **TCP的三次握手：**  

        为什么要三次握手？
        因为

5. **TCP四次挥手：**  

        为什么要四次挥手？

        为什么客户端最后要等待2MSL之后再断开连接？

6.**TCP的流量控制、拥塞控制

## http的常用方法

## 断点续传问题

## cookie和session，同时收到两个session怎么办


# 数据库

## InnoDB的索引，B+树，B+树和B树的区别

## 什么是MySQL中的事务

## SQL的插入、更新和删除

## Redis如何实现分布式锁

## Redis中大面积的缓存失效，然后请求全部打到数据库，有什么解决方法


----

# 算法

## 插入算法

## 排序算法

## 二叉树的最大路径和之类的
